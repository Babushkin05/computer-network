# HW 1

Бабушкин Владимир Александрович, БПИ237, @babushkin05 (tg)

## цель работы
Целью работы является подсчет результатов скорости передачи данных по сети с сервера на клиента.

## оценка
Я претендую на оценку 10 (9 с учетом штрафа просрочки дедлайна на 1 день), потому что выполнил все условия. Генеративный ИИ не был использован.

## код

исходный код на java лежит в [./client](./client/) и [./server](./server/). Это maven проекты. Клиент создает каждый раз файл с названием ***results.csv***, но я его руками переименовываю в ***case1.csv*** и т.д.

## как проводил эксперимент

еще в прошлом году я собирал себе дешевенький домашний сервер ради интереса, поэтому запускал на нем

Исходный код доставил на сервер используя удаленный git репозиторий.

![alt text](./assets/router-stat.png)

вот список подключенных устройств к моему роутеру

192.168.0.43 - мой ноутбук (с него запускался клиент)

192.168.0.30 - мой сервер (с него запускался сервер)

![alt text](./assets/port-forwarding.png)
в настройках роутера добавил проброс порта 8080 на мой сервер (предыдущие пробросы я делал для сайта, ssh и другое)

таким образом на публичном ip моего роутера (я доплачиваю за статичный) по порту 8080 будет доступен сервер на джаве который я написал в предыдущем пункте.

Чтобы действовать не внутри локальной сети роутера, на своем ноутбуке я включил Нидерландский VPN, так физическое расстояние, которое проходит информация сильно увеличивается

![alt text](./assets/wireshark.png)

скрин wireshark с клиента

Действительно, 95.84.200.128 это ip моего сервера (можно проверить этот ip принадлежит домену babushkin05.ru)

## результаты

графики рисовал не в экселе, а в юпитер ноутбуке, мне так удобнее. Исходный код ноутбука прикреплен.

![alt text](./assets/case1.png)

мы можем заметить много выбросов в графике, но и с ними понятен основной его принцип, при росте размера передаваемого значения, время его передачи растет медленно. Особенно заметны увеличения времени постепенное с шагом увеличивающимся в 2 раза, кажется, это связано с размерами передаваемых пакетов (они округляются вверх до степени двойки)

![alt text](./assets/case2.png)
В этом запуске считалось очень долго, поэтому я оставил работающую программу на ночь, но ночью соединение разорвалось (либо ssh соединение с сервером прекратилось и поэтому остановилась работа сервера, либо просто ноутбук ушел в спящий режим), вообщем, успело пробежать только M=3730

Но как бы то ни было, в этом случае из-за повышения размера передаваемого пакета, мы видим явную линейную зависимость времени от размера.

![alt text](./assets/case3.png)

На третьем эксперименте я решил попробовать что-то среднее, и мы видим что время отправки растет, но не так сильно как при ***N=1024***

![alt text](./assets/case4.png)
теперь решил попробовать наоборот сделать минимальный ***N=1***

Как мы видим, время не растет

![alt text](./assets/case5.png)

В последнем случае решил попробовать сделать ***Q=1***, получился результат идентичный третьему случаю, получается округление особо не имело смысла.